c
page.follow
page.follow_redirect
page.follow_redirect!
follow_redirect!
page.current_path
page.current_page
c
page.current_path
sleep 3
click_on 'Join Game'
fill_in 'join_code', with: @join_code
c
find_button('Join Game').click
find_button('Join Game')
page.current_path
click_button 'Join Game'
c
@join_code
c
expect(page).to have_content "Users Not Joined ( 1 )"
find(".randezvous-join-code").text
find(".randezvous-join-code").html
find(".randezvous-join-code")
c
redirect_if_not_playing_game
c
cc
c
users.count <= 1
c
users.count <= 1
user.blank? || status != 'pregame'
c
users.count
users.count <= 1
status != 'pregame'
user.blank?
c
game = Game.find_by(join_code: params[:join_code])
Game.find_by(join_code: params[:join_code])
c
ActionCable.server.transmissions
transmissions
c
params
c
games_user_ids
games_users.map(&:users_game_name).compact.length < 2games_user_ids
games_users.map(&:users_game_name).compact
games_users.map(&:users_game_name).compact.length < 2
 games_user_ids.length < 2
c
@user1 = @game.users.first
@game.users.count
c
continue
c
@__inspect_output
c
@__inspect_output
c
@__inspect_output
c
@__inspect_output
@_routes
@__memoized
instance_variables
game
example
c
methods.sort - Object.methods
methods.sort
@new_user
@game
@example
instance_variables
args
a
metadata
c
        expect(gus.length).to eq 3
        expect(midgame.cards.length).to eq 6
        expect(midgame.midgame?).to eq true
        expect(midgame.pregame?).to eq false
        expect(midgame.description_first?).to eq true
        expect(midgame.join_code).to be_nil
expect(midgame.valid?).to eq true
users.pluck(:id)
JSON.parse(midgame.passing_order)
c
continue
c
User.count
c
User.count
c
evaluator.callback_wanted
c
evaluator.callback
evaluator
c
continue
c
evaluator
evaluator.overrides
evaluator.instance_variables
evaluator
continue
c
continue
c
game.users.count
c
game.users.count
User.count
c
User.count
c
User.count
game
game.users
c
midgame_with_no_moves.description_first?
midgame_with_no_moves.join_code
midgame_with_no_moves.valid?
midgame_with_no_moves.postgame?
expect( JSON.parse(midgame_with_no_moves.passing_order) ).to match_array(users.pluck(:id))
users.pluck(:id)
JSON.parse(midgame_with_no_moves.passing_order)
c
@placeholder_card
c
gu.starting_card.child_card.id
gu.starting_card.id
gu = g.games_users[1]
g.games_users
g = u.current_game
g = user.current_game
game
gu
gu = u.games_users[1]
gu = u.games_user[1]
u = User.find(current_user_id)
current_user_id
Card.ids
Card.with_attached_drawing.joins(blobs: :attachments).where(medium: 'drawing')
Card.with_attached_drawing.joins(blobs: :attachments)
Card.with_attached_drawing.includes(blobs: :attachments)
Card.with_attached_drawing.join(blobs: :attachments)
c
Card.with_attached_drawing.where(uploader_id: current_user_id, starting_games_user_id: games_users.ids, medium: 'description').length
Card.with_attached_drawing.where(uploader_id: current_user_id, starting_games_user_id: games_users.ids, medium: 'description')
c
gu2.starting_card
gu2_placeholder
2787
_.id
game.get_placeholder_card gu2.user_id
c
gu1_placeholder.id
game.get_placeholder_card(gu1.user_id).id
gu1_placeholder
game.get_placeholder_card gu1.user_id
c
        expect(midgame_with_no_moves.postgame?).to eq false
        expect( JSON.parse(midgame_with_no_moves.passing_order) ).to match_array(users.pluck(:id))
users.pluck(:id)
JSON.parse(midgame_with_no_moves.passing_order)
users.ids
users.names
users.ids
users
c
    ActionCable.server.broadcast("rendezvous_#{params[:join_code]}", start_game_signal: games_path)
streams
params[:join_code]
@game
c
    ActionCable.server.broadcast("rendezvous_#{params[:join_code]}", start_game_signal: games_path)
games_path
Game.start_game params[:join_code]
c
@game.status
@game.users.count
c
 perform :start_game
@gu1.cards
@gu1
c
@prev_card = @placeholder_card.try(:parent_card) || Card.none
@current_user = current_user
response.status
@placeholder_card.try(:parent_card)
c
response.status
response.body
c
@placeholder_card
c
Card.where(uploader_id: current_user_id, starting_games_user_id: games_users.ids).order(:id).try(:first)
Card.where(uploader_id: current_user_id, starting_games_user_id: games_users.ids)
c
FactoryBot.create(:drawing, :placeholder)
Card.with_attached_drawing.where(uploader_id: @current_user_id)
Card.with_attached_drawing.where(uploader_id: @current_user_id, card_type: :drawing).first
Card.with_attached_drawing.where(uploader_id: @current_user_id, card_type: :drawing)
Card.with_attached_drawing.where(uploader_id: current_user_id, card_type: :drawing)
@current_user
Card.with_attached_drawing.where(uploader_id: current_user_id, card_type: :drawing, attached: true)
@game
c
    end
      @game ||= current_user.try(:current_game)
    def set_game
set_game
@game
@game.get_placeholder_card current_user.id
c
cookies.signed[:user_id]
current_user
logged_in?
c
get games_path
c
response.body
c
response.body
c
Game.count
Game.last
@game
c
@game.try(:pregame?)
game.try(:pregame?)
different_game_type_chosen?(params[:game_type], @game.game_type)
c
game.cards.count
gu3.starting_card.child_card.child_card
gu3.starting_card.child_card.child_card.child_card
c
gu2.starting_card.child_card.child_card.child_card
gu2.starting_card.child_card.child_card
c
gu2.starting_card.child_card
gu2.starting_card.child_card.child_card
gu1.starting_card.child_card.child_card.child_card
gu1.starting_card.child_card.child_card
gu1.starting_card.child_card
gu1.starting_card
c
killall fac
c
game.cards.count
c
gu1.starting_card
